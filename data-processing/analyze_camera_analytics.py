#!/usr/bin/env python3
"""
Generate analytics PDF from camera test summary CSV.

This script reads the summary.csv file generated by plot_test_data.py and creates
a comprehensive PDF report with plots of image means grouped by aperture size and position.

Usage:
    python analyze_camera_analytics.py <summary_csv_path>

Arguments:
    summary_csv_path: Path to the summary.csv file (e.g., qisda_data/output/summary.csv)
"""

import sys
import pandas as pd
import matplotlib.pyplot as plt
import matplotlib.backends.backend_pdf
import numpy as np
import re
from pathlib import Path


def extract_aperture_size(relative_path):
    """
    Extract aperture size from relative path.
    Looks for patterns like "3mm", "1.5mm", "0.75mm", etc.
    
    Args:
        relative_path (str): Relative path string
        
    Returns:
        str: Aperture size (e.g., "3mm", "1.5mm", "0.75mm") or "Unknown"
    """
    if pd.isna(relative_path):
        return "Unknown"
    
    # Look for patterns like Xmm, X.Xmm, X.XXmm in the path
    # Pattern: digits, optional decimal point, more digits, then "mm"
    match = re.search(r'(\d+\.?\d*)mm', str(relative_path))
    if match:
        return match.group(1) + "mm"
    
    return "Unknown"


def load_and_prepare_data(csv_path):
    """
    Load the summary CSV and add aperture size column.
    
    Args:
        csv_path (str): Path to summary.csv
        
    Returns:
        pd.DataFrame: DataFrame with aperture_size column added
    """
    df = pd.read_csv(csv_path)
    
    # Extract aperture size from relative_path
    df['aperture_size'] = df['relative_path'].apply(extract_aperture_size)
    
    # Convert position from 0-indexed to 1-indexed for display
    df['position_1indexed'] = df['position'] + 1
    
    # Filter to only light histograms for mean analysis (as requested)
    # Or we can include both - let's include both but separate them
    df_light = df[df['histogram_type'] == 'light'].copy()
    df_dark = df[df['histogram_type'] == 'dark'].copy()
    
    return df, df_light, df_dark


def plot_means_by_aperture_and_position(df_light, df_dark, ax):
    """
    Create grouped bar chart of means by aperture and position.
    
    Args:
        df_light (pd.DataFrame): Light histogram data
        df_dark (pd.DataFrame): Dark histogram data
        ax: Matplotlib axis
    """
    # Group by aperture and position
    light_means = df_light.groupby(['aperture_size', 'position'])['weighted_mean'].mean().reset_index()
    dark_means = df_dark.groupby(['aperture_size', 'position'])['weighted_mean'].mean().reset_index()
    
    # Get unique apertures and positions
    apertures = sorted(df_light['aperture_size'].unique())
    positions = sorted(df_light['position'].unique())
    positions_1indexed = [p + 1 for p in positions]  # Convert to 1-indexed for display
    
    x = np.arange(len(positions))
    width = 0.35 / len(apertures)  # Adjust width based on number of apertures
    
    # Plot bars for each aperture
    for i, aperture in enumerate(apertures):
        light_vals = []
        dark_vals = []
        for pos in positions:
            light_val = light_means[(light_means['aperture_size'] == aperture) & 
                                   (light_means['position'] == pos)]['weighted_mean']
            dark_val = dark_means[(dark_means['aperture_size'] == aperture) & 
                                 (dark_means['position'] == pos)]['weighted_mean']
            light_vals.append(light_val.values[0] if len(light_val) > 0 else 0)
            dark_vals.append(dark_val.values[0] if len(dark_val) > 0 else 0)
        
        offset = (i - len(apertures)/2 + 0.5) * width * 2
        ax.bar(x + offset, light_vals, width, label=f'{aperture} Light', alpha=0.8)
        ax.bar(x + offset + width, dark_vals, width, label=f'{aperture} Dark', alpha=0.8)
    
    ax.set_xlabel('Position (cam_id)', fontsize=10)
    ax.set_ylabel('Weighted Mean', fontsize=10)
    ax.set_title('Mean Weighted Values by Aperture Size and Position', fontsize=12, fontweight='bold')
    ax.set_xticks(x)
    ax.set_xticklabels(positions_1indexed)
    ax.legend(bbox_to_anchor=(1.05, 1), loc='upper left', fontsize=8)
    ax.grid(True, alpha=0.3, axis='y')
    plt.tight_layout()


def plot_boxplot_by_aperture(df_light, df_dark, ax):
    """
    Create horizontal box plot of means grouped by aperture size (light histograms only).
    
    Args:
        df_light (pd.DataFrame): Light histogram data
        df_dark (pd.DataFrame): Dark histogram data (not used, kept for API compatibility)
        ax: Matplotlib axis
    """
    # Light histograms only
    data_to_plot = []
    labels = []
    
    apertures = sorted(df_light['aperture_size'].unique())
    
    for aperture in apertures:
        light_data = df_light[df_light['aperture_size'] == aperture]['weighted_mean'].values
        
        if len(light_data) > 0:
            data_to_plot.append(light_data)
            labels.append(f'{aperture}')
    
    bp = ax.boxplot(data_to_plot, labels=labels, patch_artist=True, vert=False)
    
    # Color the boxes
    colors = plt.cm.Set3(np.linspace(0, 1, len(bp['boxes'])))
    for patch, color in zip(bp['boxes'], colors):
        patch.set_facecolor(color)
        patch.set_alpha(0.7)
    
    # Add data point markers with jitter
    for i, data in enumerate(data_to_plot):
        # For horizontal boxplots, y-position is the box number (1-indexed), add jitter
        y_pos = i + 1
        y_jittered = y_pos + np.random.normal(0, 0.05, size=len(data))
        ax.scatter(data, y_jittered, c='black', alpha=0.5, s=20, zorder=3)
    
    ax.set_xlabel('Weighted Mean', fontsize=10)
    ax.set_ylabel('Aperture Size', fontsize=10)
    ax.set_title('Distribution of Means by Aperture Size (Light)', fontsize=12, fontweight='bold')
    ax.grid(True, alpha=0.3, axis='x')
    plt.tight_layout()


def plot_boxplot_by_aperture_dark(df_light, df_dark, ax):
    """
    Create horizontal box plot of means grouped by aperture size (dark histograms only).
    
    Args:
        df_light (pd.DataFrame): Light histogram data (not used, kept for API compatibility)
        df_dark (pd.DataFrame): Dark histogram data
        ax: Matplotlib axis
    """
    # Dark histograms only
    data_to_plot = []
    labels = []
    
    apertures = sorted(df_dark['aperture_size'].unique())
    
    for aperture in apertures:
        dark_data = df_dark[df_dark['aperture_size'] == aperture]['weighted_mean'].values
        
        if len(dark_data) > 0:
            data_to_plot.append(dark_data)
            labels.append(f'{aperture}')
    
    bp = ax.boxplot(data_to_plot, labels=labels, patch_artist=True, vert=False)
    
    # Color the boxes (using red tones for dark histograms)
    colors = plt.cm.Reds(np.linspace(0.4, 0.8, len(bp['boxes'])))
    for patch, color in zip(bp['boxes'], colors):
        patch.set_facecolor(color)
        patch.set_alpha(0.7)
    
    # Add data point markers with jitter
    for i, data in enumerate(data_to_plot):
        # For horizontal boxplots, y-position is the box number (1-indexed), add jitter
        y_pos = i + 1
        y_jittered = y_pos + np.random.normal(0, 0.05, size=len(data))
        ax.scatter(data, y_jittered, c='black', alpha=0.5, s=20, zorder=3)
    
    ax.set_xlabel('Weighted Mean', fontsize=10)
    ax.set_ylabel('Aperture Size', fontsize=10)
    ax.set_title('Distribution of Means by Aperture Size (Dark)', fontsize=12, fontweight='bold')
    ax.grid(True, alpha=0.3, axis='x')
    plt.tight_layout()


def plot_boxplot_by_position(df_light, df_dark, ax):
    """
    Create box plot of means grouped by position (cam_id).
    
    Args:
        df_light (pd.DataFrame): Light histogram data
        df_dark (pd.DataFrame): Dark histogram data
        ax: Matplotlib axis
    """
    # Combine light and dark for box plot
    data_to_plot = []
    labels = []
    
    positions = sorted(df_light['position'].unique())
    
    for pos in positions:
        light_data = df_light[df_light['position'] == pos]['weighted_mean'].values
        dark_data = df_dark[df_dark['position'] == pos]['weighted_mean'].values
        
        if len(light_data) > 0:
            data_to_plot.append(light_data)
            labels.append(f'Pos {pos + 1}\nLight')  # 1-indexed
        
        if len(dark_data) > 0:
            data_to_plot.append(dark_data)
            labels.append(f'Pos {pos + 1}\nDark')  # 1-indexed
    
    bp = ax.boxplot(data_to_plot, labels=labels, patch_artist=True)
    
    # Color the boxes
    colors = plt.cm.Set2(np.linspace(0, 1, len(bp['boxes'])))
    for patch, color in zip(bp['boxes'], colors):
        patch.set_facecolor(color)
        patch.set_alpha(0.7)
    
    # Add data point markers with jitter
    for i, data in enumerate(data_to_plot):
        # For vertical boxplots, x-position is the box number (1-indexed), add jitter
        x_pos = i + 1
        x_jittered = x_pos + np.random.normal(0, 0.05, size=len(data))
        ax.scatter(x_jittered, data, c='black', alpha=0.5, s=20, zorder=3)
    
    ax.set_ylabel('Weighted Mean', fontsize=10)
    ax.set_title('Distribution of Means by Position (cam_id)', fontsize=12, fontweight='bold')
    ax.grid(True, alpha=0.3, axis='y')
    plt.xticks(rotation=45, ha='right')
    plt.tight_layout()


def plot_scatter_aperture_vs_mean(df_light, df_dark, ax):
    """
    Create horizontal boxplot of means grouped by position (light and dark combined).
    
    Args:
        df_light (pd.DataFrame): Light histogram data
        df_dark (pd.DataFrame): Dark histogram data
        ax: Matplotlib axis
    """
    # Combine light and dark for box plot grouped by position
    data_to_plot = []
    labels = []
    
    positions = sorted(df_light['position'].unique())
    
    for pos in positions:
        # Combine light and dark data for this position
        light_data = df_light[df_light['position'] == pos]['weighted_mean'].values
        dark_data = df_dark[df_dark['position'] == pos]['weighted_mean'].values
        
        # Combine both datasets for this position
        combined_data = np.concatenate([light_data, dark_data])
        
        if len(combined_data) > 0:
            data_to_plot.append(combined_data)
            labels.append(f'Pos {pos + 1}')  # 1-indexed
    
    # Create horizontal boxplot
    bp = ax.boxplot(data_to_plot, labels=labels, patch_artist=True, vert=False)
    
    # Use a single color scheme (no color coding by position)
    color = '#4A90E2'  # Single blue color
    for patch in bp['boxes']:
        patch.set_facecolor(color)
        patch.set_alpha(0.7)
    
    # Add data point markers with jitter
    for i, data in enumerate(data_to_plot):
        # For horizontal boxplots, y-position is the box number (1-indexed), add jitter
        y_pos = i + 1
        y_jittered = y_pos + np.random.normal(0, 0.05, size=len(data))
        ax.scatter(data, y_jittered, c='black', alpha=0.5, s=20, zorder=3)
    
    ax.set_xlabel('Weighted Mean', fontsize=10)
    ax.set_ylabel('Position (cam_id)', fontsize=10)
    ax.set_title('Mean vs Aperture Size by Position', fontsize=12, fontweight='bold')
    ax.grid(True, alpha=0.3, axis='x')
    plt.tight_layout()


def create_table_plot(df_stats, title, ax):
    """
    Create a table plot from statistics DataFrame.
    
    Args:
        df_stats (pd.DataFrame): Statistics DataFrame
        title (str): Title for the table
        ax: Matplotlib axis
    """
    ax.axis('tight')
    ax.axis('off')
    
    # Flatten column names
    df_display = df_stats.copy()
    df_display.columns = ['_'.join(col).strip() if col[1] else col[0] for col in df_display.columns]
    
    table = ax.table(cellText=df_display.values,
                    rowLabels=df_display.index.to_list(),
                    colLabels=df_display.columns,
                    cellLoc='center',
                    loc='center',
                    bbox=[0, 0, 1, 1])
    
    table.auto_set_font_size(False)
    table.set_fontsize(7)
    table.scale(1, 1.5)
    
    # Style the header
    for i in range(len(df_display.columns)):
        table[(0, i)].set_facecolor('#4CAF50')
        table[(0, i)].set_text_props(weight='bold', color='white')
    
    ax.set_title(title, fontsize=12, fontweight='bold', pad=20)


def generate_pdf_report(csv_path, output_path=None):
    """
    Generate PDF analytics report from summary CSV.
    
    Args:
        csv_path (str): Path to summary.csv
        output_path (str): Optional path for output PDF (default: same directory as CSV)
    """
    csv_file = Path(csv_path)
    if not csv_file.exists():
        print(f"Error: CSV file not found: {csv_path}")
        return
    
    if output_path is None:
        output_path = csv_file.parent / "camera_analytics_report.pdf"
    else:
        output_path = Path(output_path)
    
    print(f"Loading data from: {csv_path}")
    df, df_light, df_dark = load_and_prepare_data(csv_path)
    
    print(f"Found {len(df_light)} light histograms and {len(df_dark)} dark histograms")
    print(f"Aperture sizes: {sorted(df_light['aperture_size'].unique())}")
    print(f"Positions: {sorted(df_light['position'].unique())}")
    
    # Create PDF
    pdf = matplotlib.backends.backend_pdf.PdfPages(output_path)
    
    # Page 1: Overview
    fig = plt.figure(figsize=(11, 8.5))
    fig.suptitle('Camera Test Analytics Report', fontsize=16, fontweight='bold', y=0.98)
    
    # Summary text
    ax_text = fig.add_subplot(1, 1, 1)
    ax_text.axis('off')
    summary_text = f"""
    Data Summary:
    - Total records: {len(df)}
    - Light histograms: {len(df_light)}
    - Dark histograms: {len(df_dark)}
    - Aperture sizes: {', '.join(sorted(df_light['aperture_size'].unique()))}
    - Positions (cam_id): {', '.join(map(str, sorted([p + 1 for p in df_light['position'].unique()])))}
    - Mean weighted mean (light): {df_light['weighted_mean'].mean():.2f}
    - Mean weighted mean (dark): {df_dark['weighted_mean'].mean():.2f}
    """
    ax_text.text(0.1, 0.5, summary_text, fontsize=10, verticalalignment='center',
                family='monospace', transform=ax_text.transAxes)
    
    plt.tight_layout(rect=[0, 0, 1, 0.96])
    pdf.savefig(fig, bbox_inches='tight')
    plt.close()
    
    # Page 2: Grouped bar chart
    fig, ax = plt.subplots(figsize=(11, 8.5))
    plot_means_by_aperture_and_position(df_light, df_dark, ax)
    pdf.savefig(fig, bbox_inches='tight')
    plt.close()
    
    # Page 3: Box plot by aperture (light)
    fig, ax = plt.subplots(figsize=(11, 8.5))
    plot_boxplot_by_aperture(df_light, df_dark, ax)
    pdf.savefig(fig, bbox_inches='tight')
    plt.close()
    
    # Page 4: Box plot by aperture (dark)
    fig, ax = plt.subplots(figsize=(11, 8.5))
    plot_boxplot_by_aperture_dark(df_light, df_dark, ax)
    pdf.savefig(fig, bbox_inches='tight')
    plt.close()
    
    # Additional pages: Individual aperture analysis (light histograms only, horizontal boxplots)
    apertures = sorted(df_light['aperture_size'].unique())
    for aperture in apertures:
        if aperture == "Unknown":
            continue
        
        fig, ax = plt.subplots(figsize=(11, 8.5))
        fig.suptitle(f'Aperture Size: {aperture} - Light Histograms', fontsize=14, fontweight='bold')
        
        # Light histogram by position - horizontal boxplot
        light_ap = df_light[df_light['aperture_size'] == aperture]
        positions = sorted(light_ap['position'].unique())
        positions_1indexed = [p + 1 for p in positions]  # 1-indexed for display
        
        # Prepare data for boxplot
        data_to_plot = []
        labels = []
        for pos in positions:
            pos_data = light_ap[light_ap['position'] == pos]['weighted_mean'].values
            if len(pos_data) > 0:
                data_to_plot.append(pos_data)
                labels.append(f'Pos {pos + 1}')  # 1-indexed
        
        # Create horizontal boxplot
        bp = ax.boxplot(data_to_plot, labels=labels, patch_artist=True, vert=False)
        
        # Color the boxes
        colors = plt.cm.Blues(np.linspace(0.4, 0.8, len(bp['boxes'])))
        for patch, color in zip(bp['boxes'], colors):
            patch.set_facecolor(color)
            patch.set_alpha(0.7)
        
        # Add data point markers with jitter
        for i, data in enumerate(data_to_plot):
            # For horizontal boxplots, y-position is the box number (1-indexed), add jitter
            y_pos = i + 1
            y_jittered = y_pos + np.random.normal(0, 0.05, size=len(data))
            ax.scatter(data, y_jittered, c='black', alpha=0.5, s=20, zorder=3)
        
        ax.set_xlabel('Weighted Mean', fontsize=10)
        ax.set_ylabel('Position (cam_id)', fontsize=10)
        ax.set_title('Distribution of Means by Position', fontsize=12)
        ax.grid(True, alpha=0.3, axis='x')
        
        plt.tight_layout(rect=[0, 0, 1, 0.96])
        pdf.savefig(fig, bbox_inches='tight')
        plt.close()
    
    # Additional pages: Individual aperture analysis (dark histograms only, horizontal boxplots)
    apertures = sorted(df_dark['aperture_size'].unique())
    for aperture in apertures:
        if aperture == "Unknown":
            continue
        
        fig, ax = plt.subplots(figsize=(11, 8.5))
        fig.suptitle(f'Aperture Size: {aperture} - Dark Histograms', fontsize=14, fontweight='bold')
        
        # Dark histogram by position - horizontal boxplot
        dark_ap = df_dark[df_dark['aperture_size'] == aperture]
        positions = sorted(dark_ap['position'].unique())
        positions_1indexed = [p + 1 for p in positions]  # 1-indexed for display
        
        # Prepare data for boxplot
        data_to_plot = []
        labels = []
        for pos in positions:
            pos_data = dark_ap[dark_ap['position'] == pos]['weighted_mean'].values
            if len(pos_data) > 0:
                data_to_plot.append(pos_data)
                labels.append(f'Pos {pos + 1}')  # 1-indexed
        
        # Create horizontal boxplot
        bp = ax.boxplot(data_to_plot, labels=labels, patch_artist=True, vert=False)
        
        # Color the boxes (using red tones for dark histograms)
        colors = plt.cm.Reds(np.linspace(0.4, 0.8, len(bp['boxes'])))
        for patch, color in zip(bp['boxes'], colors):
            patch.set_facecolor(color)
            patch.set_alpha(0.7)
        
        # Add data point markers with jitter
        for i, data in enumerate(data_to_plot):
            # For horizontal boxplots, y-position is the box number (1-indexed), add jitter
            y_pos = i + 1
            y_jittered = y_pos + np.random.normal(0, 0.05, size=len(data))
            ax.scatter(data, y_jittered, c='black', alpha=0.5, s=20, zorder=3)
        
        ax.set_xlabel('Weighted Mean', fontsize=10)
        ax.set_ylabel('Position (cam_id)', fontsize=10)
        ax.set_title('Distribution of Means by Position', fontsize=12)
        ax.grid(True, alpha=0.3, axis='x')
        
        plt.tight_layout(rect=[0, 0, 1, 0.96])
        pdf.savefig(fig, bbox_inches='tight')
        plt.close()
    
    pdf.close()
    print(f"\nPDF report saved to: {output_path}")


def main():
    """Main function to handle command line arguments."""
    if len(sys.argv) < 2:
        print("Usage: python analyze_camera_analytics.py <summary_csv_path> [output_pdf_path]")
        print("Example: python analyze_camera_analytics.py qisda_data/output/summary.csv")
        sys.exit(1)
    
    csv_path = sys.argv[1]
    output_path = sys.argv[2] if len(sys.argv) > 2 else None
    
    generate_pdf_report(csv_path, output_path)


if __name__ == "__main__":
    main()

